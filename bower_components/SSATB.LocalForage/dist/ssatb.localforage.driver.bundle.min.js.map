{"version":3,"sources":["localforage.js","angular-localForage.js","localForage-ssatbDriver.js","localForage-ssatbHttpProvider.js","ssatb.authtokenrefresh.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","localforage","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","nextTick","draining","oldQueue","len","queue","immediate","task","push","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","document","createTextNode","observe","characterData","data","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","2","INTERNAL","Promise","resolver","TypeError","state","PENDING","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","value","returnValue","handlers","reject","resolve","getThen","obj","then","apply","arguments","thenable","onError","onSuccess","tryToUnwrap","result","tryCatch","status","out","reason","all","iterable","allResolver","resolveFromAll","outValue","values","resolved","error","Object","prototype","toString","Array","race","response","REJECTED","FULFILLED","constructor","3","4","_classCallCheck","instance","Constructor","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","isIndexedDBValid","idb","openDatabase","navigator","userAgent","test","open","IDBKeyRange","isWebSQLValid","isLocalStorageValid","localStorage","setItem","createBlob","parts","properties","Blob","name","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","type","executeCallback","callback","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_checkBlobSupportWithoutCaching","txn","Promise$1","blob","objectStore","DETECT_BLOB_SUPPORT_STORE","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","match","matchedEdge","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_getConnection","upgradeNeeded","db","close","dbArgs","version","openreq","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","console","warn","newVersion","onerror","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","base64","btoa","target","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","arrayBuff","atob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_initStorage","options","ignoreErrors","forages","ready","initPromises","j","forage","slice","_defaultConfig","k","getItem","key","String","store","transaction","req","get","undefined","iterate","iterator","openCursor","iterationNumber","cursor","blobSupport","err","removeItem","clear","count","advanced","advance","keys","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","p","buffer","bytes","BASE_CHARS","indexOf","bufferToString","base64String","substring","serialize","valueString","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","str","BLOB_TYPE_PREFIX","TYPE_BLOB","readAsArrayBuffer","JSON","stringify","deserialize","SERIALIZED_MARKER_LENGTH","parse","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","setItem$1","originalValue","sqlError","QUOTA_ERR","removeItem$1","clear$1","length$1","c","key$1","keys$1","_initStorage$2","keyPrefix","clear$2","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","length$2","removeItem$2","setItem$2","executeTwoCallbacks","errorCallback","callWhenReady","localForageInstance","libraryMethod","_args","extend","arg","hasOwnProperty","isArray","isLibraryDriver","driverName","driver","DriverType","_typeof","Symbol","asyncStorage","_driver","webSQLStorage","localStorageWrapper","CustomDrivers","INDEXEDDB","LOCALSTORAGE","WEBSQL","DefaultDriverOrder","LibraryMethods","DefaultConfig","driverSupport","LocalForage","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","config","replace","defineDriver","driverObject","complianceError","namingError","customDriverMethods","concat","customDriverMethod","supportPromise","_support","supportResult","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_extend","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","createInstance","localforage_js","root","factory","angular","angularLocalForage","provider","lfInstances","defaultConfig","notify","watchers","setNotify","itemSet","itemRemove","isObject","$get","$rootScope","$q","$parse","LocalForageInstance","params","isDefined","_localforage","isUndefined","isString","promises","forEach","index","deferred","defer","args","localCopy","copy","$promise","prefix","$broadcast","newvalue","rejectOnNull","res","found","shouldResolve","pull","keyList","oldPrefix","tempKeyList","substr","getKeys","bind","$scope","opts","defaultOpts","defaultValue","scopeKey","model","assign","$watch","val","unbind","fct","directive","$localForage","restrict","link","$element","$attrs","$eval","localForage","localforageSsatbDriver","DRIVER_NAME","_apiInfo","apiInfo","appendServiceResponseHeaders","jqXHR","headers","headersStr","getAllResponseHeaders","headersArray","split","header","kvs","trim","responseHeaders","getDefaultApiDetails","$","ajax","method","verb","url","Url","Headers","cache","dataType","contentType","done","items","keyProperty","fail","textStatus","errorThrown","getServerError","apiDetails","getApiDetails","serviceName","responseStatus","api","apiHashmap","defaultKey","firstKey","statusText","responseJSON","ModuleType","DEFINE","EXPORT","WINDOW","moduleType","$localForageProvider","getApiNameByUrl","service","toLowerCase","interceptorFactories","interceptors","$injector","ssatbHttp","requestConfig","uppercase","requestInterceptors","responseInterceptors","when","reversedInterceptors","interceptor","request","requestError","unshift","responseError","chainInterceptors","createShortMethods","names","createShortMethodsWithData","ii","thenFn","rejectFn","interceptorFactory","invoke","authTokenRefreshService","$window","$http","refreshToken","refreshTokenBaseUrl","refreshTokenComplete","refreshTokenUrl","messageInterceptorsConfig","$provide","errorResponse","getServiceNameFromApiInfo","apiInfoObject","ServiceName","retry","errorHandler","_retrySsatbHttpRequest","$ssatbHttp","alertDialog","ssatbHttpProvider"],"mappings":"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","file":"ssatb.localforage.driver.bundle.min.js","sourcesContent":["/*!\r\n    localForage -- Offline Storage, Improved\r\n    Version 1.4.2\r\n    https://mozilla.github.io/localForage\r\n    (c) 2013-2015 Mozilla, Apache License 2.0\r\n*/\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\n(function (global){\r\n'use strict';\r\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\r\n\r\nvar scheduleDrain;\r\n\r\n{\r\n  if (Mutation) {\r\n    var called = 0;\r\n    var observer = new Mutation(nextTick);\r\n    var element = global.document.createTextNode('');\r\n    observer.observe(element, {\r\n      characterData: true\r\n    });\r\n    scheduleDrain = function () {\r\n      element.data = (called = ++called % 2);\r\n    };\r\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\r\n    var channel = new global.MessageChannel();\r\n    channel.port1.onmessage = nextTick;\r\n    scheduleDrain = function () {\r\n      channel.port2.postMessage(0);\r\n    };\r\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\r\n    scheduleDrain = function () {\r\n\r\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\r\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\r\n      var scriptEl = global.document.createElement('script');\r\n      scriptEl.onreadystatechange = function () {\r\n        nextTick();\r\n\r\n        scriptEl.onreadystatechange = null;\r\n        scriptEl.parentNode.removeChild(scriptEl);\r\n        scriptEl = null;\r\n      };\r\n      global.document.documentElement.appendChild(scriptEl);\r\n    };\r\n  } else {\r\n    scheduleDrain = function () {\r\n      setTimeout(nextTick, 0);\r\n    };\r\n  }\r\n}\r\n\r\nvar draining;\r\nvar queue = [];\r\n//named nextTick for less confusing stack traces\r\nfunction nextTick() {\r\n  draining = true;\r\n  var i, oldQueue;\r\n  var len = queue.length;\r\n  while (len) {\r\n    oldQueue = queue;\r\n    queue = [];\r\n    i = -1;\r\n    while (++i < len) {\r\n      oldQueue[i]();\r\n    }\r\n    len = queue.length;\r\n  }\r\n  draining = false;\r\n}\r\n\r\nmodule.exports = immediate;\r\nfunction immediate(task) {\r\n  if (queue.push(task) === 1 && !draining) {\r\n    scheduleDrain();\r\n  }\r\n}\r\n\r\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],2:[function(_dereq_,module,exports){\r\n'use strict';\r\nvar immediate = _dereq_(1);\r\n\r\n/* istanbul ignore next */\r\nfunction INTERNAL() {}\r\n\r\nvar handlers = {};\r\n\r\nvar REJECTED = ['REJECTED'];\r\nvar FULFILLED = ['FULFILLED'];\r\nvar PENDING = ['PENDING'];\r\n\r\nmodule.exports = exports = Promise;\r\n\r\nfunction Promise(resolver) {\r\n  if (typeof resolver !== 'function') {\r\n    throw new TypeError('resolver must be a function');\r\n  }\r\n  this.state = PENDING;\r\n  this.queue = [];\r\n  this.outcome = void 0;\r\n  if (resolver !== INTERNAL) {\r\n    safelyResolveThenable(this, resolver);\r\n  }\r\n}\r\n\r\nPromise.prototype[\"catch\"] = function (onRejected) {\r\n  return this.then(null, onRejected);\r\n};\r\nPromise.prototype.then = function (onFulfilled, onRejected) {\r\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\r\n    typeof onRejected !== 'function' && this.state === REJECTED) {\r\n    return this;\r\n  }\r\n  var promise = new this.constructor(INTERNAL);\r\n  if (this.state !== PENDING) {\r\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\r\n    unwrap(promise, resolver, this.outcome);\r\n  } else {\r\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\r\n  }\r\n\r\n  return promise;\r\n};\r\nfunction QueueItem(promise, onFulfilled, onRejected) {\r\n  this.promise = promise;\r\n  if (typeof onFulfilled === 'function') {\r\n    this.onFulfilled = onFulfilled;\r\n    this.callFulfilled = this.otherCallFulfilled;\r\n  }\r\n  if (typeof onRejected === 'function') {\r\n    this.onRejected = onRejected;\r\n    this.callRejected = this.otherCallRejected;\r\n  }\r\n}\r\nQueueItem.prototype.callFulfilled = function (value) {\r\n  handlers.resolve(this.promise, value);\r\n};\r\nQueueItem.prototype.otherCallFulfilled = function (value) {\r\n  unwrap(this.promise, this.onFulfilled, value);\r\n};\r\nQueueItem.prototype.callRejected = function (value) {\r\n  handlers.reject(this.promise, value);\r\n};\r\nQueueItem.prototype.otherCallRejected = function (value) {\r\n  unwrap(this.promise, this.onRejected, value);\r\n};\r\n\r\nfunction unwrap(promise, func, value) {\r\n  immediate(function () {\r\n    var returnValue;\r\n    try {\r\n      returnValue = func(value);\r\n    } catch (e) {\r\n      return handlers.reject(promise, e);\r\n    }\r\n    if (returnValue === promise) {\r\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\r\n    } else {\r\n      handlers.resolve(promise, returnValue);\r\n    }\r\n  });\r\n}\r\n\r\nhandlers.resolve = function (self, value) {\r\n  var result = tryCatch(getThen, value);\r\n  if (result.status === 'error') {\r\n    return handlers.reject(self, result.value);\r\n  }\r\n  var thenable = result.value;\r\n\r\n  if (thenable) {\r\n    safelyResolveThenable(self, thenable);\r\n  } else {\r\n    self.state = FULFILLED;\r\n    self.outcome = value;\r\n    var i = -1;\r\n    var len = self.queue.length;\r\n    while (++i < len) {\r\n      self.queue[i].callFulfilled(value);\r\n    }\r\n  }\r\n  return self;\r\n};\r\nhandlers.reject = function (self, error) {\r\n  self.state = REJECTED;\r\n  self.outcome = error;\r\n  var i = -1;\r\n  var len = self.queue.length;\r\n  while (++i < len) {\r\n    self.queue[i].callRejected(error);\r\n  }\r\n  return self;\r\n};\r\n\r\nfunction getThen(obj) {\r\n  // Make sure we only access the accessor once as required by the spec\r\n  var then = obj && obj.then;\r\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\r\n    return function appyThen() {\r\n      then.apply(obj, arguments);\r\n    };\r\n  }\r\n}\r\n\r\nfunction safelyResolveThenable(self, thenable) {\r\n  // Either fulfill, reject or reject with error\r\n  var called = false;\r\n  function onError(value) {\r\n    if (called) {\r\n      return;\r\n    }\r\n    called = true;\r\n    handlers.reject(self, value);\r\n  }\r\n\r\n  function onSuccess(value) {\r\n    if (called) {\r\n      return;\r\n    }\r\n    called = true;\r\n    handlers.resolve(self, value);\r\n  }\r\n\r\n  function tryToUnwrap() {\r\n    thenable(onSuccess, onError);\r\n  }\r\n\r\n  var result = tryCatch(tryToUnwrap);\r\n  if (result.status === 'error') {\r\n    onError(result.value);\r\n  }\r\n}\r\n\r\nfunction tryCatch(func, value) {\r\n  var out = {};\r\n  try {\r\n    out.value = func(value);\r\n    out.status = 'success';\r\n  } catch (e) {\r\n    out.status = 'error';\r\n    out.value = e;\r\n  }\r\n  return out;\r\n}\r\n\r\nexports.resolve = resolve;\r\nfunction resolve(value) {\r\n  if (value instanceof this) {\r\n    return value;\r\n  }\r\n  return handlers.resolve(new this(INTERNAL), value);\r\n}\r\n\r\nexports.reject = reject;\r\nfunction reject(reason) {\r\n  var promise = new this(INTERNAL);\r\n  return handlers.reject(promise, reason);\r\n}\r\n\r\nexports.all = all;\r\nfunction all(iterable) {\r\n  var self = this;\r\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\r\n    return this.reject(new TypeError('must be an array'));\r\n  }\r\n\r\n  var len = iterable.length;\r\n  var called = false;\r\n  if (!len) {\r\n    return this.resolve([]);\r\n  }\r\n\r\n  var values = new Array(len);\r\n  var resolved = 0;\r\n  var i = -1;\r\n  var promise = new this(INTERNAL);\r\n\r\n  while (++i < len) {\r\n    allResolver(iterable[i], i);\r\n  }\r\n  return promise;\r\n  function allResolver(value, i) {\r\n    self.resolve(value).then(resolveFromAll, function (error) {\r\n      if (!called) {\r\n        called = true;\r\n        handlers.reject(promise, error);\r\n      }\r\n    });\r\n    function resolveFromAll(outValue) {\r\n      values[i] = outValue;\r\n      if (++resolved === len && !called) {\r\n        called = true;\r\n        handlers.resolve(promise, values);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexports.race = race;\r\nfunction race(iterable) {\r\n  var self = this;\r\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\r\n    return this.reject(new TypeError('must be an array'));\r\n  }\r\n\r\n  var len = iterable.length;\r\n  var called = false;\r\n  if (!len) {\r\n    return this.resolve([]);\r\n  }\r\n\r\n  var i = -1;\r\n  var promise = new this(INTERNAL);\r\n\r\n  while (++i < len) {\r\n    resolver(iterable[i]);\r\n  }\r\n  return promise;\r\n  function resolver(value) {\r\n    self.resolve(value).then(function (response) {\r\n      if (!called) {\r\n        called = true;\r\n        handlers.resolve(promise, response);\r\n      }\r\n    }, function (error) {\r\n      if (!called) {\r\n        called = true;\r\n        handlers.reject(promise, error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n},{\"1\":1}],3:[function(_dereq_,module,exports){\r\n(function (global){\r\n'use strict';\r\nif (typeof global.Promise !== 'function') {\r\n  global.Promise = _dereq_(2);\r\n}\r\n\r\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"2\":2}],4:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction getIDB() {\r\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\r\n    if (typeof indexedDB !== 'undefined') {\r\n        return indexedDB;\r\n    }\r\n    if (typeof webkitIndexedDB !== 'undefined') {\r\n        return webkitIndexedDB;\r\n    }\r\n    if (typeof mozIndexedDB !== 'undefined') {\r\n        return mozIndexedDB;\r\n    }\r\n    if (typeof OIndexedDB !== 'undefined') {\r\n        return OIndexedDB;\r\n    }\r\n    if (typeof msIndexedDB !== 'undefined') {\r\n        return msIndexedDB;\r\n    }\r\n}\r\n\r\nvar idb = getIDB();\r\n\r\nfunction isIndexedDBValid() {\r\n    try {\r\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\r\n        // if needed.\r\n        if (!idb) {\r\n            return false;\r\n        }\r\n        // We mimic PouchDB here; just UA test for Safari (which, as of\r\n        // iOS 8/Yosemite, doesn't properly support IndexedDB).\r\n        // IndexedDB support is broken and different from Blink's.\r\n        // This is faster than the test case (and it's sync), so we just\r\n        // do this. *SIGH*\r\n        // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/\r\n        //\r\n        // We test for openDatabase because IE Mobile identifies itself\r\n        // as Safari. Oh the lulz...\r\n        if (typeof openDatabase !== 'undefined' && typeof navigator !== 'undefined' && navigator.userAgent && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {\r\n            return false;\r\n        }\r\n\r\n        return idb && typeof idb.open === 'function' &&\r\n        // Some Samsung/HTC Android 4.0-4.3 devices\r\n        // have older IndexedDB specs; if this isn't available\r\n        // their IndexedDB is too old for us to use.\r\n        // (Replaces the onupgradeneeded test.)\r\n        typeof IDBKeyRange !== 'undefined';\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction isWebSQLValid() {\r\n    return typeof openDatabase === 'function';\r\n}\r\n\r\nfunction isLocalStorageValid() {\r\n    try {\r\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\n// Abstracts constructing a Blob object, so it also works in older\r\n// browsers that don't support the native Blob constructor. (i.e.\r\n// old QtWebKit versions, at least).\r\n// Abstracts constructing a Blob object, so it also works in older\r\n// browsers that don't support the native Blob constructor. (i.e.\r\n// old QtWebKit versions, at least).\r\nfunction createBlob(parts, properties) {\r\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\r\n    parts = parts || [];\r\n    properties = properties || {};\r\n    try {\r\n        return new Blob(parts, properties);\r\n    } catch (e) {\r\n        if (e.name !== 'TypeError') {\r\n            throw e;\r\n        }\r\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\r\n        var builder = new Builder();\r\n        for (var i = 0; i < parts.length; i += 1) {\r\n            builder.append(parts[i]);\r\n        }\r\n        return builder.getBlob(properties.type);\r\n    }\r\n}\r\n\r\n// This is CommonJS because lie is an external dependency, so Rollup\r\n// can just ignore it.\r\nif (typeof Promise === 'undefined' && typeof _dereq_ !== 'undefined') {\r\n    _dereq_(3);\r\n}\r\nvar Promise$1 = Promise;\r\n\r\nfunction executeCallback(promise, callback) {\r\n    if (callback) {\r\n        promise.then(function (result) {\r\n            callback(null, result);\r\n        }, function (error) {\r\n            callback(error);\r\n        });\r\n    }\r\n}\r\n\r\n// Some code originally from async_storage.js in\r\n// [Gaia](https://github.com/mozilla-b2g/gaia).\r\n\r\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\r\nvar supportsBlobs;\r\nvar dbContexts;\r\n\r\n// Transform a binary string to an array buffer, because otherwise\r\n// weird stuff happens when you try to work with the binary string directly.\r\n// It is known.\r\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\r\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\r\nfunction _binStringToArrayBuffer(bin) {\r\n    var length = bin.length;\r\n    var buf = new ArrayBuffer(length);\r\n    var arr = new Uint8Array(buf);\r\n    for (var i = 0; i < length; i++) {\r\n        arr[i] = bin.charCodeAt(i);\r\n    }\r\n    return buf;\r\n}\r\n\r\n//\r\n// Blobs are not supported in all versions of IndexedDB, notably\r\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\r\n//\r\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\r\n// Detecting them is expensive and confusing to users, and Chrome 37-42\r\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\r\n//\r\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\r\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\r\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\r\n//\r\n// Code borrowed from PouchDB. See:\r\n// https://github.com/pouchdb/pouchdb/blob/9c25a23/src/adapters/idb/blobSupport.js\r\n//\r\nfunction _checkBlobSupportWithoutCaching(txn) {\r\n    return new Promise$1(function (resolve) {\r\n        var blob = createBlob(['']);\r\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\r\n\r\n        txn.onabort = function (e) {\r\n            // If the transaction aborts now its due to not being able to\r\n            // write to the database, likely due to the disk being full\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            resolve(false);\r\n        };\r\n\r\n        txn.oncomplete = function () {\r\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\r\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\r\n            // MS Edge pretends to be Chrome 42:\r\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\r\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\r\n        };\r\n    })[\"catch\"](function () {\r\n        return false; // error, so assume unsupported\r\n    });\r\n}\r\n\r\nfunction _checkBlobSupport(idb) {\r\n    if (typeof supportsBlobs === 'boolean') {\r\n        return Promise$1.resolve(supportsBlobs);\r\n    }\r\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\r\n        supportsBlobs = value;\r\n        return supportsBlobs;\r\n    });\r\n}\r\n\r\nfunction _deferReadiness(dbInfo) {\r\n    var dbContext = dbContexts[dbInfo.name];\r\n\r\n    // Create a deferred object representing the current database operation.\r\n    var deferredOperation = {};\r\n\r\n    deferredOperation.promise = new Promise$1(function (resolve) {\r\n        deferredOperation.resolve = resolve;\r\n    });\r\n\r\n    // Enqueue the deferred operation.\r\n    dbContext.deferredOperations.push(deferredOperation);\r\n\r\n    // Chain its promise to the database readiness.\r\n    if (!dbContext.dbReady) {\r\n        dbContext.dbReady = deferredOperation.promise;\r\n    } else {\r\n        dbContext.dbReady = dbContext.dbReady.then(function () {\r\n            return deferredOperation.promise;\r\n        });\r\n    }\r\n}\r\n\r\nfunction _advanceReadiness(dbInfo) {\r\n    var dbContext = dbContexts[dbInfo.name];\r\n\r\n    // Dequeue a deferred operation.\r\n    var deferredOperation = dbContext.deferredOperations.pop();\r\n\r\n    // Resolve its promise (which is part of the database readiness\r\n    // chain of promises).\r\n    if (deferredOperation) {\r\n        deferredOperation.resolve();\r\n    }\r\n}\r\n\r\nfunction _getConnection(dbInfo, upgradeNeeded) {\r\n    return new Promise$1(function (resolve, reject) {\r\n\r\n        if (dbInfo.db) {\r\n            if (upgradeNeeded) {\r\n                _deferReadiness(dbInfo);\r\n                dbInfo.db.close();\r\n            } else {\r\n                return resolve(dbInfo.db);\r\n            }\r\n        }\r\n\r\n        var dbArgs = [dbInfo.name];\r\n\r\n        if (upgradeNeeded) {\r\n            dbArgs.push(dbInfo.version);\r\n        }\r\n\r\n        var openreq = idb.open.apply(idb, dbArgs);\r\n\r\n        if (upgradeNeeded) {\r\n            openreq.onupgradeneeded = function (e) {\r\n                var db = openreq.result;\r\n                try {\r\n                    db.createObjectStore(dbInfo.storeName);\r\n                    if (e.oldVersion <= 1) {\r\n                        // Added when support for blob shims was added\r\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\r\n                    }\r\n                } catch (ex) {\r\n                    if (ex.name === 'ConstraintError') {\r\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\r\n                    } else {\r\n                        throw ex;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        openreq.onerror = function () {\r\n            reject(openreq.error);\r\n        };\r\n\r\n        openreq.onsuccess = function () {\r\n            resolve(openreq.result);\r\n            _advanceReadiness(dbInfo);\r\n        };\r\n    });\r\n}\r\n\r\nfunction _getOriginalConnection(dbInfo) {\r\n    return _getConnection(dbInfo, false);\r\n}\r\n\r\nfunction _getUpgradedConnection(dbInfo) {\r\n    return _getConnection(dbInfo, true);\r\n}\r\n\r\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\r\n    if (!dbInfo.db) {\r\n        return true;\r\n    }\r\n\r\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\r\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\r\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\r\n\r\n    if (isDowngrade) {\r\n        // If the version is not the default one\r\n        // then warn for impossible downgrade.\r\n        if (dbInfo.version !== defaultVersion) {\r\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\r\n        }\r\n        // Align the versions to prevent errors.\r\n        dbInfo.version = dbInfo.db.version;\r\n    }\r\n\r\n    if (isUpgrade || isNewStore) {\r\n        // If the store is new then increment the version (if needed).\r\n        // This will trigger an \"upgradeneeded\" event which is required\r\n        // for creating a store.\r\n        if (isNewStore) {\r\n            var incVersion = dbInfo.db.version + 1;\r\n            if (incVersion > dbInfo.version) {\r\n                dbInfo.version = incVersion;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// encode a blob for indexeddb engines that don't support blobs\r\nfunction _encodeBlob(blob) {\r\n    return new Promise$1(function (resolve, reject) {\r\n        var reader = new FileReader();\r\n        reader.onerror = reject;\r\n        reader.onloadend = function (e) {\r\n            var base64 = btoa(e.target.result || '');\r\n            resolve({\r\n                __local_forage_encoded_blob: true,\r\n                data: base64,\r\n                type: blob.type\r\n            });\r\n        };\r\n        reader.readAsBinaryString(blob);\r\n    });\r\n}\r\n\r\n// decode an encoded blob\r\nfunction _decodeBlob(encodedBlob) {\r\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\r\n    return createBlob([arrayBuff], { type: encodedBlob.type });\r\n}\r\n\r\n// is this one of our fancy encoded blobs?\r\nfunction _isEncodedBlob(value) {\r\n    return value && value.__local_forage_encoded_blob;\r\n}\r\n\r\n// Specialize the default `ready()` function by making it dependent\r\n// on the current database operations. Thus, the driver will be actually\r\n// ready when it's been initialized (default) *and* there are no pending\r\n// operations on the database (initiated by some other instances).\r\nfunction _fullyReady(callback) {\r\n    var self = this;\r\n\r\n    var promise = self._initReady().then(function () {\r\n        var dbContext = dbContexts[self._dbInfo.name];\r\n\r\n        if (dbContext && dbContext.dbReady) {\r\n            return dbContext.dbReady;\r\n        }\r\n    });\r\n\r\n    promise.then(callback, callback);\r\n    return promise;\r\n}\r\n\r\n// Open the IndexedDB database (automatically creates one if one didn't\r\n// previously exist), using any options set in the config.\r\nfunction _initStorage(options) {\r\n    var self = this;\r\n    var dbInfo = {\r\n        db: null\r\n    };\r\n\r\n    if (options) {\r\n        for (var i in options) {\r\n            dbInfo[i] = options[i];\r\n        }\r\n    }\r\n\r\n    // Initialize a singleton container for all running localForages.\r\n    if (!dbContexts) {\r\n        dbContexts = {};\r\n    }\r\n\r\n    // Get the current context of the database;\r\n    var dbContext = dbContexts[dbInfo.name];\r\n\r\n    // ...or create a new context.\r\n    if (!dbContext) {\r\n        dbContext = {\r\n            // Running localForages sharing a database.\r\n            forages: [],\r\n            // Shared database.\r\n            db: null,\r\n            // Database readiness (promise).\r\n            dbReady: null,\r\n            // Deferred operations on the database.\r\n            deferredOperations: []\r\n        };\r\n        // Register the new context in the global container.\r\n        dbContexts[dbInfo.name] = dbContext;\r\n    }\r\n\r\n    // Register itself as a running localForage in the current context.\r\n    dbContext.forages.push(self);\r\n\r\n    // Replace the default `ready()` function with the specialized one.\r\n    if (!self._initReady) {\r\n        self._initReady = self.ready;\r\n        self.ready = _fullyReady;\r\n    }\r\n\r\n    // Create an array of initialization states of the related localForages.\r\n    var initPromises = [];\r\n\r\n    function ignoreErrors() {\r\n        // Don't handle errors here,\r\n        // just makes sure related localForages aren't pending.\r\n        return Promise$1.resolve();\r\n    }\r\n\r\n    for (var j = 0; j < dbContext.forages.length; j++) {\r\n        var forage = dbContext.forages[j];\r\n        if (forage !== self) {\r\n            // Don't wait for itself...\r\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\r\n        }\r\n    }\r\n\r\n    // Take a snapshot of the related localForages.\r\n    var forages = dbContext.forages.slice(0);\r\n\r\n    // Initialize the connection process only when\r\n    // all the related localForages aren't pending.\r\n    return Promise$1.all(initPromises).then(function () {\r\n        dbInfo.db = dbContext.db;\r\n        // Get the connection or open a new one without upgrade.\r\n        return _getOriginalConnection(dbInfo);\r\n    }).then(function (db) {\r\n        dbInfo.db = db;\r\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\r\n            // Reopen the database for upgrading.\r\n            return _getUpgradedConnection(dbInfo);\r\n        }\r\n        return db;\r\n    }).then(function (db) {\r\n        dbInfo.db = dbContext.db = db;\r\n        self._dbInfo = dbInfo;\r\n        // Share the final connection amongst related localForages.\r\n        for (var k = 0; k < forages.length; k++) {\r\n            var forage = forages[k];\r\n            if (forage !== self) {\r\n                // Self is already up-to-date.\r\n                forage._dbInfo.db = dbInfo.db;\r\n                forage._dbInfo.version = dbInfo.version;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction getItem(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\r\n            var req = store.get(key);\r\n\r\n            req.onsuccess = function () {\r\n                var value = req.result;\r\n                if (value === undefined) {\r\n                    value = null;\r\n                }\r\n                if (_isEncodedBlob(value)) {\r\n                    value = _decodeBlob(value);\r\n                }\r\n                resolve(value);\r\n            };\r\n\r\n            req.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Iterate over all items stored in database.\r\nfunction iterate(iterator, callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\r\n\r\n            var req = store.openCursor();\r\n            var iterationNumber = 1;\r\n\r\n            req.onsuccess = function () {\r\n                var cursor = req.result;\r\n\r\n                if (cursor) {\r\n                    var value = cursor.value;\r\n                    if (_isEncodedBlob(value)) {\r\n                        value = _decodeBlob(value);\r\n                    }\r\n                    var result = iterator(value, cursor.key, iterationNumber++);\r\n\r\n                    if (result !== void 0) {\r\n                        resolve(result);\r\n                    } else {\r\n                        cursor[\"continue\"]();\r\n                    }\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            req.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n\r\n    return promise;\r\n}\r\n\r\nfunction setItem(key, value, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        var dbInfo;\r\n        self.ready().then(function () {\r\n            dbInfo = self._dbInfo;\r\n            if (value instanceof Blob) {\r\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\r\n                    if (blobSupport) {\r\n                        return value;\r\n                    }\r\n                    return _encodeBlob(value);\r\n                });\r\n            }\r\n            return value;\r\n        }).then(function (value) {\r\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\r\n            var store = transaction.objectStore(dbInfo.storeName);\r\n\r\n            // The reason we don't _save_ null is because IE 10 does\r\n            // not support saving the `null` type in IndexedDB. How\r\n            // ironic, given the bug below!\r\n            // See: https://github.com/mozilla/localForage/issues/161\r\n            if (value === null) {\r\n                value = undefined;\r\n            }\r\n\r\n            transaction.oncomplete = function () {\r\n                // Cast to undefined so the value passed to\r\n                // callback/promise is the same as what one would get out\r\n                // of `getItem()` later. This leads to some weirdness\r\n                // (setItem('foo', undefined) will return `null`), but\r\n                // it's not my fault localStorage is our baseline and that\r\n                // it's weird.\r\n                if (value === undefined) {\r\n                    value = null;\r\n                }\r\n\r\n                resolve(value);\r\n            };\r\n            transaction.onabort = transaction.onerror = function () {\r\n                var err = req.error ? req.error : req.transaction.error;\r\n                reject(err);\r\n            };\r\n\r\n            var req = store.put(value, key);\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction removeItem(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\r\n            var store = transaction.objectStore(dbInfo.storeName);\r\n\r\n            // We use a Grunt task to make this safe for IE and some\r\n            // versions of Android (including those used by Cordova).\r\n            // Normally IE won't like `.delete()` and will insist on\r\n            // using `['delete']()`, but we have a build step that\r\n            // fixes this for us now.\r\n            var req = store[\"delete\"](key);\r\n            transaction.oncomplete = function () {\r\n                resolve();\r\n            };\r\n\r\n            transaction.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n\r\n            // The request will be also be aborted if we've exceeded our storage\r\n            // space.\r\n            transaction.onabort = function () {\r\n                var err = req.error ? req.error : req.transaction.error;\r\n                reject(err);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction clear(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\r\n            var store = transaction.objectStore(dbInfo.storeName);\r\n            var req = store.clear();\r\n\r\n            transaction.oncomplete = function () {\r\n                resolve();\r\n            };\r\n\r\n            transaction.onabort = transaction.onerror = function () {\r\n                var err = req.error ? req.error : req.transaction.error;\r\n                reject(err);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction length(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\r\n            var req = store.count();\r\n\r\n            req.onsuccess = function () {\r\n                resolve(req.result);\r\n            };\r\n\r\n            req.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction key(n, callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        if (n < 0) {\r\n            resolve(null);\r\n\r\n            return;\r\n        }\r\n\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\r\n\r\n            var advanced = false;\r\n            var req = store.openCursor();\r\n            req.onsuccess = function () {\r\n                var cursor = req.result;\r\n                if (!cursor) {\r\n                    // this means there weren't enough keys\r\n                    resolve(null);\r\n\r\n                    return;\r\n                }\r\n\r\n                if (n === 0) {\r\n                    // We have the first key, return it if that's what they\r\n                    // wanted.\r\n                    resolve(cursor.key);\r\n                } else {\r\n                    if (!advanced) {\r\n                        // Otherwise, ask the cursor to skip ahead n\r\n                        // records.\r\n                        advanced = true;\r\n                        cursor.advance(n);\r\n                    } else {\r\n                        // When we get here, we've got the nth key.\r\n                        resolve(cursor.key);\r\n                    }\r\n                }\r\n            };\r\n\r\n            req.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction keys(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\r\n\r\n            var req = store.openCursor();\r\n            var keys = [];\r\n\r\n            req.onsuccess = function () {\r\n                var cursor = req.result;\r\n\r\n                if (!cursor) {\r\n                    resolve(keys);\r\n                    return;\r\n                }\r\n\r\n                keys.push(cursor.key);\r\n                cursor[\"continue\"]();\r\n            };\r\n\r\n            req.onerror = function () {\r\n                reject(req.error);\r\n            };\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nvar asyncStorage = {\r\n    _driver: 'asyncStorage',\r\n    _initStorage: _initStorage,\r\n    iterate: iterate,\r\n    getItem: getItem,\r\n    setItem: setItem,\r\n    removeItem: removeItem,\r\n    clear: clear,\r\n    length: length,\r\n    key: key,\r\n    keys: keys\r\n};\r\n\r\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\r\n// it to Base64, so this is how we store it to prevent very strange errors with less\r\n// verbose ways of binary <-> string data storage.\r\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\r\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\r\n\r\nvar SERIALIZED_MARKER = '__lfsc__:';\r\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\r\n\r\n// OMG the serializations!\r\nvar TYPE_ARRAYBUFFER = 'arbf';\r\nvar TYPE_BLOB = 'blob';\r\nvar TYPE_INT8ARRAY = 'si08';\r\nvar TYPE_UINT8ARRAY = 'ui08';\r\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\r\nvar TYPE_INT16ARRAY = 'si16';\r\nvar TYPE_INT32ARRAY = 'si32';\r\nvar TYPE_UINT16ARRAY = 'ur16';\r\nvar TYPE_UINT32ARRAY = 'ui32';\r\nvar TYPE_FLOAT32ARRAY = 'fl32';\r\nvar TYPE_FLOAT64ARRAY = 'fl64';\r\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\r\n\r\nfunction stringToBuffer(serializedString) {\r\n    // Fill the string into a ArrayBuffer.\r\n    var bufferLength = serializedString.length * 0.75;\r\n    var len = serializedString.length;\r\n    var i;\r\n    var p = 0;\r\n    var encoded1, encoded2, encoded3, encoded4;\r\n\r\n    if (serializedString[serializedString.length - 1] === '=') {\r\n        bufferLength--;\r\n        if (serializedString[serializedString.length - 2] === '=') {\r\n            bufferLength--;\r\n        }\r\n    }\r\n\r\n    var buffer = new ArrayBuffer(bufferLength);\r\n    var bytes = new Uint8Array(buffer);\r\n\r\n    for (i = 0; i < len; i += 4) {\r\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\r\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\r\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\r\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\r\n\r\n        /*jslint bitwise: true */\r\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\r\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\r\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\r\n    }\r\n    return buffer;\r\n}\r\n\r\n// Converts a buffer to a string to store, serialized, in the backend\r\n// storage library.\r\nfunction bufferToString(buffer) {\r\n    // base64-arraybuffer\r\n    var bytes = new Uint8Array(buffer);\r\n    var base64String = '';\r\n    var i;\r\n\r\n    for (i = 0; i < bytes.length; i += 3) {\r\n        /*jslint bitwise: true */\r\n        base64String += BASE_CHARS[bytes[i] >> 2];\r\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\r\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\r\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\r\n    }\r\n\r\n    if (bytes.length % 3 === 2) {\r\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\r\n    } else if (bytes.length % 3 === 1) {\r\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\r\n    }\r\n\r\n    return base64String;\r\n}\r\n\r\n// Serialize a value, afterwards executing a callback (which usually\r\n// instructs the `setItem()` callback/promise to be executed). This is how\r\n// we store binary data with localStorage.\r\nfunction serialize(value, callback) {\r\n    var valueString = '';\r\n    if (value) {\r\n        valueString = value.toString();\r\n    }\r\n\r\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\r\n    // checks fail when running the tests using casper.js...\r\n    //\r\n    // TODO: See why those tests fail and use a better solution.\r\n    if (value && (value.toString() === '[object ArrayBuffer]' || value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {\r\n        // Convert binary arrays to a string and prefix the string with\r\n        // a special marker.\r\n        var buffer;\r\n        var marker = SERIALIZED_MARKER;\r\n\r\n        if (value instanceof ArrayBuffer) {\r\n            buffer = value;\r\n            marker += TYPE_ARRAYBUFFER;\r\n        } else {\r\n            buffer = value.buffer;\r\n\r\n            if (valueString === '[object Int8Array]') {\r\n                marker += TYPE_INT8ARRAY;\r\n            } else if (valueString === '[object Uint8Array]') {\r\n                marker += TYPE_UINT8ARRAY;\r\n            } else if (valueString === '[object Uint8ClampedArray]') {\r\n                marker += TYPE_UINT8CLAMPEDARRAY;\r\n            } else if (valueString === '[object Int16Array]') {\r\n                marker += TYPE_INT16ARRAY;\r\n            } else if (valueString === '[object Uint16Array]') {\r\n                marker += TYPE_UINT16ARRAY;\r\n            } else if (valueString === '[object Int32Array]') {\r\n                marker += TYPE_INT32ARRAY;\r\n            } else if (valueString === '[object Uint32Array]') {\r\n                marker += TYPE_UINT32ARRAY;\r\n            } else if (valueString === '[object Float32Array]') {\r\n                marker += TYPE_FLOAT32ARRAY;\r\n            } else if (valueString === '[object Float64Array]') {\r\n                marker += TYPE_FLOAT64ARRAY;\r\n            } else {\r\n                callback(new Error('Failed to get type for BinaryArray'));\r\n            }\r\n        }\r\n\r\n        callback(marker + bufferToString(buffer));\r\n    } else if (valueString === '[object Blob]') {\r\n        // Conver the blob to a binaryArray and then to a string.\r\n        var fileReader = new FileReader();\r\n\r\n        fileReader.onload = function () {\r\n            // Backwards-compatible prefix for the blob type.\r\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\r\n\r\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\r\n        };\r\n\r\n        fileReader.readAsArrayBuffer(value);\r\n    } else {\r\n        try {\r\n            callback(JSON.stringify(value));\r\n        } catch (e) {\r\n            console.error(\"Couldn't convert value into a JSON string: \", value);\r\n\r\n            callback(null, e);\r\n        }\r\n    }\r\n}\r\n\r\n// Deserialize data we've inserted into a value column/field. We place\r\n// special markers into our strings to mark them as encoded; this isn't\r\n// as nice as a meta field, but it's the only sane thing we can do whilst\r\n// keeping localStorage support intact.\r\n//\r\n// Oftentimes this will just deserialize JSON content, but if we have a\r\n// special marker (SERIALIZED_MARKER, defined above), we will extract\r\n// some kind of arraybuffer/binary data/typed array out of the string.\r\nfunction deserialize(value) {\r\n    // If we haven't marked this string as being specially serialized (i.e.\r\n    // something other than serialized JSON), we can just return it and be\r\n    // done with it.\r\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\r\n        return JSON.parse(value);\r\n    }\r\n\r\n    // The following code deals with deserializing some kind of Blob or\r\n    // TypedArray. First we separate out the type of data we're dealing\r\n    // with from the data itself.\r\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\r\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\r\n\r\n    var blobType;\r\n    // Backwards-compatible blob type serialization strategy.\r\n    // DBs created with older versions of localForage will simply not have the blob type.\r\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\r\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\r\n        blobType = matcher[1];\r\n        serializedString = serializedString.substring(matcher[0].length);\r\n    }\r\n    var buffer = stringToBuffer(serializedString);\r\n\r\n    // Return the right type based on the code/type set during\r\n    // serialization.\r\n    switch (type) {\r\n        case TYPE_ARRAYBUFFER:\r\n            return buffer;\r\n        case TYPE_BLOB:\r\n            return createBlob([buffer], { type: blobType });\r\n        case TYPE_INT8ARRAY:\r\n            return new Int8Array(buffer);\r\n        case TYPE_UINT8ARRAY:\r\n            return new Uint8Array(buffer);\r\n        case TYPE_UINT8CLAMPEDARRAY:\r\n            return new Uint8ClampedArray(buffer);\r\n        case TYPE_INT16ARRAY:\r\n            return new Int16Array(buffer);\r\n        case TYPE_UINT16ARRAY:\r\n            return new Uint16Array(buffer);\r\n        case TYPE_INT32ARRAY:\r\n            return new Int32Array(buffer);\r\n        case TYPE_UINT32ARRAY:\r\n            return new Uint32Array(buffer);\r\n        case TYPE_FLOAT32ARRAY:\r\n            return new Float32Array(buffer);\r\n        case TYPE_FLOAT64ARRAY:\r\n            return new Float64Array(buffer);\r\n        default:\r\n            throw new Error('Unkown type: ' + type);\r\n    }\r\n}\r\n\r\nvar localforageSerializer = {\r\n    serialize: serialize,\r\n    deserialize: deserialize,\r\n    stringToBuffer: stringToBuffer,\r\n    bufferToString: bufferToString\r\n};\r\n\r\n/*\r\n * Includes code from:\r\n *\r\n * base64-arraybuffer\r\n * https://github.com/niklasvh/base64-arraybuffer\r\n *\r\n * Copyright (c) 2012 Niklas von Hertzen\r\n * Licensed under the MIT license.\r\n */\r\n// Open the WebSQL database (automatically creates one if one didn't\r\n// previously exist), using any options set in the config.\r\nfunction _initStorage$1(options) {\r\n    var self = this;\r\n    var dbInfo = {\r\n        db: null\r\n    };\r\n\r\n    if (options) {\r\n        for (var i in options) {\r\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\r\n        }\r\n    }\r\n\r\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\r\n        // Open the database; the openDatabase API will automatically\r\n        // create it for us if it doesn't exist.\r\n        try {\r\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\r\n        } catch (e) {\r\n            return reject(e);\r\n        }\r\n\r\n        // Create our key/value table if it doesn't exist.\r\n        dbInfo.db.transaction(function (t) {\r\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\r\n                self._dbInfo = dbInfo;\r\n                resolve();\r\n            }, function (t, error) {\r\n                reject(error);\r\n            });\r\n        });\r\n    });\r\n\r\n    dbInfo.serializer = localforageSerializer;\r\n    return dbInfoPromise;\r\n}\r\n\r\nfunction getItem$1(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\r\n                    var result = results.rows.length ? results.rows.item(0).value : null;\r\n\r\n                    // Check to see if this is serialized content we need to\r\n                    // unpack.\r\n                    if (result) {\r\n                        result = dbInfo.serializer.deserialize(result);\r\n                    }\r\n\r\n                    resolve(result);\r\n                }, function (t, error) {\r\n\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction iterate$1(iterator, callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                    var rows = results.rows;\r\n                    var length = rows.length;\r\n\r\n                    for (var i = 0; i < length; i++) {\r\n                        var item = rows.item(i);\r\n                        var result = item.value;\r\n\r\n                        // Check to see if this is serialized content\r\n                        // we need to unpack.\r\n                        if (result) {\r\n                            result = dbInfo.serializer.deserialize(result);\r\n                        }\r\n\r\n                        result = iterator(result, item.key, i + 1);\r\n\r\n                        // void(0) prevents problems with redefinition\r\n                        // of `undefined`.\r\n                        if (result !== void 0) {\r\n                            resolve(result);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    resolve();\r\n                }, function (t, error) {\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction setItem$1(key, value, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            // The localStorage API doesn't return undefined values in an\r\n            // \"expected\" way, so undefined is always cast to null in all\r\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\r\n            if (value === undefined) {\r\n                value = null;\r\n            }\r\n\r\n            // Save the original value to pass to the callback.\r\n            var originalValue = value;\r\n\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.serializer.serialize(value, function (value, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                } else {\r\n                    dbInfo.db.transaction(function (t) {\r\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\r\n                            resolve(originalValue);\r\n                        }, function (t, error) {\r\n                            reject(error);\r\n                        });\r\n                    }, function (sqlError) {\r\n                        // The transaction failed; check\r\n                        // to see if it's a quota error.\r\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\r\n                            // We reject the callback outright for now, but\r\n                            // it's worth trying to re-run the transaction.\r\n                            // Even if the user accepts the prompt to use\r\n                            // more storage on Safari, this error will\r\n                            // be called.\r\n                            //\r\n                            // TODO: Try to re-run the transaction.\r\n                            reject(sqlError);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction removeItem$1(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\r\n                    resolve();\r\n                }, function (t, error) {\r\n\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Deletes every item in the table.\r\n// TODO: Find out if this resets the AUTO_INCREMENT number.\r\nfunction clear$1(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\r\n                    resolve();\r\n                }, function (t, error) {\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Does a simple `COUNT(key)` to get the number of items stored in\r\n// localForage.\r\nfunction length$1(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                // Ahhh, SQL makes this one soooooo easy.\r\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                    var result = results.rows.item(0).c;\r\n\r\n                    resolve(result);\r\n                }, function (t, error) {\r\n\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Return the key located at key index X; essentially gets the key from a\r\n// `WHERE id = ?`. This is the most efficient way I can think to implement\r\n// this rarely-used (in my experience) part of the API, but it can seem\r\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\r\n// the ID of each key will change every time it's updated. Perhaps a stored\r\n// procedure for the `setItem()` SQL would solve this problem?\r\n// TODO: Don't change ID on `setItem()`.\r\nfunction key$1(n, callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\r\n                    var result = results.rows.length ? results.rows.item(0).key : null;\r\n                    resolve(result);\r\n                }, function (t, error) {\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction keys$1(callback) {\r\n    var self = this;\r\n\r\n    var promise = new Promise$1(function (resolve, reject) {\r\n        self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.db.transaction(function (t) {\r\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                    var keys = [];\r\n\r\n                    for (var i = 0; i < results.rows.length; i++) {\r\n                        keys.push(results.rows.item(i).key);\r\n                    }\r\n\r\n                    resolve(keys);\r\n                }, function (t, error) {\r\n\r\n                    reject(error);\r\n                });\r\n            });\r\n        })[\"catch\"](reject);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nvar webSQLStorage = {\r\n    _driver: 'webSQLStorage',\r\n    _initStorage: _initStorage$1,\r\n    iterate: iterate$1,\r\n    getItem: getItem$1,\r\n    setItem: setItem$1,\r\n    removeItem: removeItem$1,\r\n    clear: clear$1,\r\n    length: length$1,\r\n    key: key$1,\r\n    keys: keys$1\r\n};\r\n\r\n// Config the localStorage backend, using options set in the config.\r\nfunction _initStorage$2(options) {\r\n    var self = this;\r\n    var dbInfo = {};\r\n    if (options) {\r\n        for (var i in options) {\r\n            dbInfo[i] = options[i];\r\n        }\r\n    }\r\n\r\n    dbInfo.keyPrefix = dbInfo.name + '/';\r\n\r\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\r\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\r\n    }\r\n\r\n    self._dbInfo = dbInfo;\r\n    dbInfo.serializer = localforageSerializer;\r\n\r\n    return Promise$1.resolve();\r\n}\r\n\r\n// Remove all keys from the datastore, effectively destroying all data in\r\n// the app's key/value store!\r\nfunction clear$2(callback) {\r\n    var self = this;\r\n    var promise = self.ready().then(function () {\r\n        var keyPrefix = self._dbInfo.keyPrefix;\r\n\r\n        for (var i = localStorage.length - 1; i >= 0; i--) {\r\n            var key = localStorage.key(i);\r\n\r\n            if (key.indexOf(keyPrefix) === 0) {\r\n                localStorage.removeItem(key);\r\n            }\r\n        }\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Retrieve an item from the store. Unlike the original async_storage\r\n// library in Gaia, we don't modify return values at all. If a key's value\r\n// is `undefined`, we pass that value to the callback function.\r\nfunction getItem$2(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = self.ready().then(function () {\r\n        var dbInfo = self._dbInfo;\r\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\r\n\r\n        // If a result was found, parse it from the serialized\r\n        // string into a JS object. If result isn't truthy, the key\r\n        // is likely undefined and we'll pass it straight to the\r\n        // callback.\r\n        if (result) {\r\n            result = dbInfo.serializer.deserialize(result);\r\n        }\r\n\r\n        return result;\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Iterate over all items in the store.\r\nfunction iterate$2(iterator, callback) {\r\n    var self = this;\r\n\r\n    var promise = self.ready().then(function () {\r\n        var dbInfo = self._dbInfo;\r\n        var keyPrefix = dbInfo.keyPrefix;\r\n        var keyPrefixLength = keyPrefix.length;\r\n        var length = localStorage.length;\r\n\r\n        // We use a dedicated iterator instead of the `i` variable below\r\n        // so other keys we fetch in localStorage aren't counted in\r\n        // the `iterationNumber` argument passed to the `iterate()`\r\n        // callback.\r\n        //\r\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\r\n        var iterationNumber = 1;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            var key = localStorage.key(i);\r\n            if (key.indexOf(keyPrefix) !== 0) {\r\n                continue;\r\n            }\r\n            var value = localStorage.getItem(key);\r\n\r\n            // If a result was found, parse it from the serialized\r\n            // string into a JS object. If result isn't truthy, the\r\n            // key is likely undefined and we'll pass it straight\r\n            // to the iterator.\r\n            if (value) {\r\n                value = dbInfo.serializer.deserialize(value);\r\n            }\r\n\r\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\r\n\r\n            if (value !== void 0) {\r\n                return value;\r\n            }\r\n        }\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Same as localStorage's key() method, except takes a callback.\r\nfunction key$2(n, callback) {\r\n    var self = this;\r\n    var promise = self.ready().then(function () {\r\n        var dbInfo = self._dbInfo;\r\n        var result;\r\n        try {\r\n            result = localStorage.key(n);\r\n        } catch (error) {\r\n            result = null;\r\n        }\r\n\r\n        // Remove the prefix from the key, if a key is found.\r\n        if (result) {\r\n            result = result.substring(dbInfo.keyPrefix.length);\r\n        }\r\n\r\n        return result;\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nfunction keys$2(callback) {\r\n    var self = this;\r\n    var promise = self.ready().then(function () {\r\n        var dbInfo = self._dbInfo;\r\n        var length = localStorage.length;\r\n        var keys = [];\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\r\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Supply the number of keys in the datastore to the callback function.\r\nfunction length$2(callback) {\r\n    var self = this;\r\n    var promise = self.keys().then(function (keys) {\r\n        return keys.length;\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Remove an item from the store, nice and simple.\r\nfunction removeItem$2(key, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = self.ready().then(function () {\r\n        var dbInfo = self._dbInfo;\r\n        localStorage.removeItem(dbInfo.keyPrefix + key);\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\n// Set a key's value and run an optional callback once the value is set.\r\n// Unlike Gaia's implementation, the callback function is passed the value,\r\n// in case you want to operate on that value only after you're sure it\r\n// saved, or something like that.\r\nfunction setItem$2(key, value, callback) {\r\n    var self = this;\r\n\r\n    // Cast the key to a string, as that's all we can set as a key.\r\n    if (typeof key !== 'string') {\r\n        console.warn(key + ' used as a key, but it is not a string.');\r\n        key = String(key);\r\n    }\r\n\r\n    var promise = self.ready().then(function () {\r\n        // Convert undefined values to null.\r\n        // https://github.com/mozilla/localForage/pull/42\r\n        if (value === undefined) {\r\n            value = null;\r\n        }\r\n\r\n        // Save the original value to pass to the callback.\r\n        var originalValue = value;\r\n\r\n        return new Promise$1(function (resolve, reject) {\r\n            var dbInfo = self._dbInfo;\r\n            dbInfo.serializer.serialize(value, function (value, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                } else {\r\n                    try {\r\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\r\n                        resolve(originalValue);\r\n                    } catch (e) {\r\n                        // localStorage capacity exceeded.\r\n                        // TODO: Make this a specific error/event.\r\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\r\n                            reject(e);\r\n                        }\r\n                        reject(e);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    });\r\n\r\n    executeCallback(promise, callback);\r\n    return promise;\r\n}\r\n\r\nvar localStorageWrapper = {\r\n    _driver: 'localStorageWrapper',\r\n    _initStorage: _initStorage$2,\r\n    // Default API, from Gaia/localStorage.\r\n    iterate: iterate$2,\r\n    getItem: getItem$2,\r\n    setItem: setItem$2,\r\n    removeItem: removeItem$2,\r\n    clear: clear$2,\r\n    length: length$2,\r\n    key: key$2,\r\n    keys: keys$2\r\n};\r\n\r\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\r\n    if (typeof callback === 'function') {\r\n        promise.then(callback);\r\n    }\r\n\r\n    if (typeof errorCallback === 'function') {\r\n        promise[\"catch\"](errorCallback);\r\n    }\r\n}\r\n\r\n// Custom drivers are stored here when `defineDriver()` is called.\r\n// They are shared across all instances of localForage.\r\nvar CustomDrivers = {};\r\n\r\nvar DriverType = {\r\n    INDEXEDDB: 'asyncStorage',\r\n    LOCALSTORAGE: 'localStorageWrapper',\r\n    WEBSQL: 'webSQLStorage'\r\n};\r\n\r\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\r\n\r\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\r\n\r\nvar DefaultConfig = {\r\n    description: '',\r\n    driver: DefaultDriverOrder.slice(),\r\n    name: 'localforage',\r\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\r\n    // we can use without a prompt.\r\n    size: 4980736,\r\n    storeName: 'keyvaluepairs',\r\n    version: 1.0\r\n};\r\n\r\nvar driverSupport = {};\r\n// Check to see if IndexedDB is available and if it is the latest\r\n// implementation; it's our preferred backend library. We use \"_spec_test\"\r\n// as the name of the database because it's not the one we'll operate on,\r\n// but it's useful to make sure its using the right spec.\r\n// See: https://github.com/mozilla/localForage/issues/128\r\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\r\n\r\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\r\n\r\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\r\n\r\nvar isArray = Array.isArray || function (arg) {\r\n    return Object.prototype.toString.call(arg) === '[object Array]';\r\n};\r\n\r\nfunction callWhenReady(localForageInstance, libraryMethod) {\r\n    localForageInstance[libraryMethod] = function () {\r\n        var _args = arguments;\r\n        return localForageInstance.ready().then(function () {\r\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\r\n        });\r\n    };\r\n}\r\n\r\nfunction extend() {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n        var arg = arguments[i];\r\n\r\n        if (arg) {\r\n            for (var key in arg) {\r\n                if (arg.hasOwnProperty(key)) {\r\n                    if (isArray(arg[key])) {\r\n                        arguments[0][key] = arg[key].slice();\r\n                    } else {\r\n                        arguments[0][key] = arg[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return arguments[0];\r\n}\r\n\r\nfunction isLibraryDriver(driverName) {\r\n    for (var driver in DriverType) {\r\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvar LocalForage = function () {\r\n    function LocalForage(options) {\r\n        _classCallCheck(this, LocalForage);\r\n\r\n        this.INDEXEDDB = DriverType.INDEXEDDB;\r\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\r\n        this.WEBSQL = DriverType.WEBSQL;\r\n\r\n        this._defaultConfig = extend({}, DefaultConfig);\r\n        this._config = extend({}, this._defaultConfig, options);\r\n        this._driverSet = null;\r\n        this._initDriver = null;\r\n        this._ready = false;\r\n        this._dbInfo = null;\r\n\r\n        this._wrapLibraryMethodsWithReady();\r\n        this.setDriver(this._config.driver);\r\n    }\r\n\r\n    // Set any config values for localForage; can be called anytime before\r\n    // the first API call (e.g. `getItem`, `setItem`).\r\n    // We loop through options so we don't overwrite existing config\r\n    // values.\r\n\r\n\r\n    LocalForage.prototype.config = function config(options) {\r\n        // If the options argument is an object, we use it to set values.\r\n        // Otherwise, we return either a specified config value or all\r\n        // config values.\r\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\r\n            // If localforage is ready and fully initialized, we can't set\r\n            // any new configuration values. Instead, we return an error.\r\n            if (this._ready) {\r\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\r\n            }\r\n\r\n            for (var i in options) {\r\n                if (i === 'storeName') {\r\n                    options[i] = options[i].replace(/\\W/g, '_');\r\n                }\r\n\r\n                this._config[i] = options[i];\r\n            }\r\n\r\n            // after all config options are set and\r\n            // the driver option is used, try setting it\r\n            if ('driver' in options && options.driver) {\r\n                this.setDriver(this._config.driver);\r\n            }\r\n\r\n            return true;\r\n        } else if (typeof options === 'string') {\r\n            return this._config[options];\r\n        } else {\r\n            return this._config;\r\n        }\r\n    };\r\n\r\n    // Used to define a custom driver, shared across all instances of\r\n    // localForage.\r\n\r\n\r\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            try {\r\n                var driverName = driverObject._driver;\r\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\r\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\r\n\r\n                // A driver name should be defined and not overlap with the\r\n                // library-defined, default drivers.\r\n                if (!driverObject._driver) {\r\n                    reject(complianceError);\r\n                    return;\r\n                }\r\n                if (isLibraryDriver(driverObject._driver)) {\r\n                    reject(namingError);\r\n                    return;\r\n                }\r\n\r\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\r\n                for (var i = 0; i < customDriverMethods.length; i++) {\r\n                    var customDriverMethod = customDriverMethods[i];\r\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\r\n                        reject(complianceError);\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                var supportPromise = Promise$1.resolve(true);\r\n                if ('_support' in driverObject) {\r\n                    if (driverObject._support && typeof driverObject._support === 'function') {\r\n                        supportPromise = driverObject._support();\r\n                    } else {\r\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\r\n                    }\r\n                }\r\n\r\n                supportPromise.then(function (supportResult) {\r\n                    driverSupport[driverName] = supportResult;\r\n                    CustomDrivers[driverName] = driverObject;\r\n                    resolve();\r\n                }, reject);\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n\r\n        executeTwoCallbacks(promise, callback, errorCallback);\r\n        return promise;\r\n    };\r\n\r\n    LocalForage.prototype.driver = function driver() {\r\n        return this._driver || null;\r\n    };\r\n\r\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\r\n        var self = this;\r\n        var getDriverPromise = Promise$1.resolve().then(function () {\r\n            if (isLibraryDriver(driverName)) {\r\n                switch (driverName) {\r\n                    case self.INDEXEDDB:\r\n                        return asyncStorage;\r\n                    case self.LOCALSTORAGE:\r\n                        return localStorageWrapper;\r\n                    case self.WEBSQL:\r\n                        return webSQLStorage;\r\n                }\r\n            } else if (CustomDrivers[driverName]) {\r\n                return CustomDrivers[driverName];\r\n            } else {\r\n                throw new Error('Driver not found.');\r\n            }\r\n        });\r\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\r\n        return getDriverPromise;\r\n    };\r\n\r\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\r\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\r\n        executeTwoCallbacks(serializerPromise, callback);\r\n        return serializerPromise;\r\n    };\r\n\r\n    LocalForage.prototype.ready = function ready(callback) {\r\n        var self = this;\r\n\r\n        var promise = self._driverSet.then(function () {\r\n            if (self._ready === null) {\r\n                self._ready = self._initDriver();\r\n            }\r\n\r\n            return self._ready;\r\n        });\r\n\r\n        executeTwoCallbacks(promise, callback, callback);\r\n        return promise;\r\n    };\r\n\r\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\r\n        var self = this;\r\n\r\n        if (!isArray(drivers)) {\r\n            drivers = [drivers];\r\n        }\r\n\r\n        var supportedDrivers = this._getSupportedDrivers(drivers);\r\n\r\n        function setDriverToConfig() {\r\n            self._config.driver = self.driver();\r\n        }\r\n\r\n        function initDriver(supportedDrivers) {\r\n            return function () {\r\n                var currentDriverIndex = 0;\r\n\r\n                function driverPromiseLoop() {\r\n                    while (currentDriverIndex < supportedDrivers.length) {\r\n                        var driverName = supportedDrivers[currentDriverIndex];\r\n                        currentDriverIndex++;\r\n\r\n                        self._dbInfo = null;\r\n                        self._ready = null;\r\n\r\n                        return self.getDriver(driverName).then(function (driver) {\r\n                            self._extend(driver);\r\n                            setDriverToConfig();\r\n\r\n                            self._ready = self._initStorage(self._config);\r\n                            return self._ready;\r\n                        })[\"catch\"](driverPromiseLoop);\r\n                    }\r\n\r\n                    setDriverToConfig();\r\n                    var error = new Error('No available storage method found.');\r\n                    self._driverSet = Promise$1.reject(error);\r\n                    return self._driverSet;\r\n                }\r\n\r\n                return driverPromiseLoop();\r\n            };\r\n        }\r\n\r\n        // There might be a driver initialization in progress\r\n        // so wait for it to finish in order to avoid a possible\r\n        // race condition to set _dbInfo\r\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\r\n            return Promise$1.resolve();\r\n        }) : Promise$1.resolve();\r\n\r\n        this._driverSet = oldDriverSetDone.then(function () {\r\n            var driverName = supportedDrivers[0];\r\n            self._dbInfo = null;\r\n            self._ready = null;\r\n\r\n            return self.getDriver(driverName).then(function (driver) {\r\n                self._driver = driver._driver;\r\n                setDriverToConfig();\r\n                self._wrapLibraryMethodsWithReady();\r\n                self._initDriver = initDriver(supportedDrivers);\r\n            });\r\n        })[\"catch\"](function () {\r\n            setDriverToConfig();\r\n            var error = new Error('No available storage method found.');\r\n            self._driverSet = Promise$1.reject(error);\r\n            return self._driverSet;\r\n        });\r\n\r\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\r\n        return this._driverSet;\r\n    };\r\n\r\n    LocalForage.prototype.supports = function supports(driverName) {\r\n        return !!driverSupport[driverName];\r\n    };\r\n\r\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\r\n        extend(this, libraryMethodsAndProperties);\r\n    };\r\n\r\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\r\n        var supportedDrivers = [];\r\n        for (var i = 0, len = drivers.length; i < len; i++) {\r\n            var driverName = drivers[i];\r\n            if (this.supports(driverName)) {\r\n                supportedDrivers.push(driverName);\r\n            }\r\n        }\r\n        return supportedDrivers;\r\n    };\r\n\r\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\r\n        // Add a stub for each driver API method that delays the call to the\r\n        // corresponding driver method until localForage is ready. These stubs\r\n        // will be replaced by the driver methods as soon as the driver is\r\n        // loaded, so there is no performance impact.\r\n        for (var i = 0; i < LibraryMethods.length; i++) {\r\n            callWhenReady(this, LibraryMethods[i]);\r\n        }\r\n    };\r\n\r\n    LocalForage.prototype.createInstance = function createInstance(options) {\r\n        return new LocalForage(options);\r\n    };\r\n\r\n    return LocalForage;\r\n}();\r\n\r\n// The actual localForage object that we expose as a module or via a\r\n// global. It's extended by pulling in one of our other libraries.\r\n\r\n\r\nvar localforage_js = new LocalForage();\r\n\r\nmodule.exports = localforage_js;\r\n\r\n},{\"3\":3}]},{},[4])(4)\r\n});","/**\r\n * angular-localforage - Angular service & directive for https://github.com/mozilla/localForage (Offline storage, improved.)\r\n * @version v1.3.1\r\n * @link https://github.com/ocombe/angular-localForage\r\n * @license MIT\r\n * @author Olivier Combe <olivier.combe@gmail.com>\r\n */\r\n(function(root, factory) {\r\n  'use strict';\r\n\r\n  var angular = (root && root.angular) || (window && window.angular);\r\n  if(typeof define === 'function' && define.amd) {                    // AMD\r\n    define(['localforage'], function(localforage) {\r\n      factory(angular, localforage);\r\n    });\r\n  } else if(typeof exports === 'object' || typeof global === 'object') {\r\n    module.exports = factory(angular, require('localforage')); // Node/Browserify\r\n  } else {\r\n    return factory(angular, root.localforage);                        // Browser\r\n  }\r\n})(this, function(angular, localforage, undefined) {\r\n  'use strict';\r\n\r\n  var angularLocalForage = angular.module('LocalForageModule', ['ng']);\r\n  angularLocalForage.provider('$localForage', function() {\r\n    var lfInstances = {},\r\n      defaultConfig = {\r\n        name: 'lf'\r\n      },\r\n    // Send signals for each of the following actions ?\r\n      notify = {\r\n        setItem: false,\r\n        removeItem: false\r\n      },\r\n      watchers = {};\r\n\r\n    // Setter for notification config, itemSet & itemRemove should be booleans\r\n    this.setNotify = function(itemSet, itemRemove) {\r\n      notify = {\r\n        setItem: itemSet,\r\n        removeItem: itemRemove\r\n      };\r\n    };\r\n\r\n    this.config = function(config) {\r\n      if(!angular.isObject(config)) {\r\n        throw new Error('The config parameter should be an object');\r\n      }\r\n      angular.extend(defaultConfig, config);\r\n    };\r\n\r\n    this.$get = ['$rootScope', '$q', '$parse', function($rootScope, $q, $parse) {\r\n      var LocalForageInstance = function LocalForageInstance(params) {\r\n        if(angular.isDefined(params)) {\r\n          this._localforage = localforage.createInstance(params);\r\n        } else {\r\n          this._localforage = localforage;\r\n          localforage.config(defaultConfig);\r\n        }\r\n      };\r\n\r\n      LocalForageInstance.prototype.createInstance = function createInstance(config) {\r\n        if(angular.isObject(config)) { // create new instance\r\n          config = angular.extend({}, defaultConfig, config);\r\n          if(angular.isDefined(lfInstances[config.name])) {\r\n            throw new Error('A localForage instance with the name ' + config.name + ' is already defined.');\r\n          }\r\n\r\n          lfInstances[config.name] = new LocalForageInstance(config);\r\n          return lfInstances[config.name];\r\n        } else {\r\n          throw new Error('The parameter should be a config object.')\r\n        }\r\n      };\r\n\r\n      LocalForageInstance.prototype.instance = function instance(name) {\r\n        if(angular.isUndefined(name)) {\r\n          return lfInstances[defaultConfig.name];\r\n        } else if(angular.isString(name)) {\r\n          if(angular.isDefined(lfInstances[name])) {\r\n            return lfInstances[name];\r\n          } else {\r\n            throw new Error('No localForage instance of that name exists.')\r\n          }\r\n        } else {\r\n          throw new Error('The parameter should be a string.')\r\n        }\r\n      };\r\n\r\n      // Setter for the storage driver\r\n      LocalForageInstance.prototype.setDriver = function setDriver(driver) {\r\n        return this._localforage.setDriver(driver);\r\n      };\r\n\r\n      // Getter for the storage driver\r\n      LocalForageInstance.prototype.driver = function driver() {\r\n        return this._localforage.driver();\r\n      };\r\n\r\n      // Directly adds a value to storage\r\n      LocalForageInstance.prototype.setItem = function setItem(key, value) {\r\n        // throw error on undefined key, we allow undefined value because... why not ?\r\n        if(angular.isUndefined(key)) {\r\n          throw new Error(\"You must define a key to set\");\r\n        }\r\n\r\n        var self = this;\r\n\r\n        if(angular.isArray(key)) {\r\n          if(!angular.isArray(value)) {\r\n            throw new Error('If you set an array of keys, the values should be an array too');\r\n          }\r\n\r\n          var promises = [];\r\n          angular.forEach(key, function(k, index) {\r\n            promises.push(self.setItem(k, value[index]))\r\n          });\r\n\r\n          return $q.all(promises);\r\n        } else {\r\n          var deferred = $q.defer(),\r\n            args = arguments,\r\n            localCopy = typeof Blob !== 'undefined' && typeof ArrayBuffer !== 'undefined' && (value instanceof Blob || value instanceof ArrayBuffer) ? value : angular.copy(value);\r\n\r\n          //avoid $promises attributes from value objects, if present.\r\n          if(angular.isObject(localCopy) && angular.isDefined(localCopy.$promise)) {\r\n            delete localCopy.$promise; //delete attribut from object structure.\r\n          }\r\n\r\n          self._localforage.setItem(self.prefix() + key, localCopy).then(function success() {\r\n            if(notify.setItem) {\r\n              $rootScope.$broadcast('LocalForageModule.setItem', {\r\n                key: key,\r\n                newvalue: localCopy,\r\n                driver: self.driver()\r\n              });\r\n            }\r\n            deferred.resolve(localCopy);\r\n          }, function error(data) {\r\n            self.onError(data, args, self.setItem, deferred);\r\n          });\r\n\r\n          return deferred.promise;\r\n        }\r\n      };\r\n\r\n      // Directly get a value from storage\r\n      LocalForageInstance.prototype.getItem = function getItem(key, rejectOnNull) {\r\n        // throw error on undefined key\r\n        if(angular.isUndefined(key)) {\r\n          throw new Error(\"You must define a key to get\");\r\n        }\r\n\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this,\r\n          promise;\r\n\r\n        if(angular.isArray(key)) {\r\n          var res = [],\r\n            found = 0;\r\n          promise = self._localforage.iterate(function(value, k) {\r\n            var index = key.indexOf(self.prefix() + k);\r\n            if(index > -1) {\r\n              res[index] = value;\r\n              found++;\r\n            }\r\n            if(found === key.length) {\r\n              return res;\r\n            }\r\n          }).then(function() {\r\n            var shouldResolve = true;\r\n            for (var i = 0; i < key.length; i++) {\r\n              if (angular.isUndefined(res[i])) {\r\n                res[i] = null;\r\n                shouldResolve = false;\r\n              }\r\n            }\r\n            if (shouldResolve || !rejectOnNull) {\r\n              deferred.resolve(res);\r\n            } else {\r\n              deferred.reject(res);\r\n            }\r\n          });\r\n        } else {\r\n          promise = self._localforage.getItem(self.prefix() + key).then(function(item) {\r\n            if (rejectOnNull && item === null) {\r\n              deferred.reject(item);\r\n            } else {\r\n              deferred.resolve(item);\r\n            }\r\n          });\r\n        }\r\n\r\n        promise.then(null, function error(data) {\r\n          self.onError(data, args, self.getItem, deferred);\r\n        });\r\n\r\n        return deferred.promise;\r\n      };\r\n\r\n      // Iterate over all the values in storage\r\n      LocalForageInstance.prototype.iterate = function iterate(callback) {\r\n        // throw error on undefined key\r\n        if(angular.isUndefined(callback)) {\r\n          throw new Error(\"You must define a callback to iterate\");\r\n        }\r\n\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this;\r\n\r\n        self._localforage.iterate(callback).then(function success(item) {\r\n          deferred.resolve(item);\r\n        }, function error(data) {\r\n          self.onError(data, args, self.iterate, deferred);\r\n        });\r\n\r\n        return deferred.promise;\r\n      };\r\n\r\n      // Remove an item from storage\r\n      LocalForageInstance.prototype.removeItem = function removeItem(key) {\r\n        // throw error on undefined key\r\n        if(angular.isUndefined(key)) {\r\n          throw new Error(\"You must define a key to remove\");\r\n        }\r\n\r\n        var self = this;\r\n\r\n        if(angular.isArray(key)) {\r\n          var promises = [];\r\n          angular.forEach(key, function(k, index) {\r\n            promises.push(self.removeItem(k));\r\n          });\r\n\r\n          return $q.all(promises);\r\n        } else {\r\n          var deferred = $q.defer(),\r\n            args = arguments;\r\n\r\n          self._localforage.removeItem(self.prefix() + key).then(function success() {\r\n            if(notify.removeItem) {\r\n              $rootScope.$broadcast('LocalForageModule.removeItem', {key: key, driver: self.driver()});\r\n            }\r\n            deferred.resolve();\r\n          }, function error(data) {\r\n            self.onError(data, args, self.removeItem, deferred);\r\n          });\r\n\r\n          return deferred.promise;\r\n        }\r\n      };\r\n\r\n      // Get an item and removes it from storage\r\n      LocalForageInstance.prototype.pull = function pull(key) {\r\n        // throw error on undefined key\r\n        if(angular.isUndefined(key)) {\r\n          throw new Error(\"You must define a key to pull\");\r\n        }\r\n\r\n        var self = this,\r\n          deferred = $q.defer(),\r\n          onError = function error(err) {\r\n            deferred.reject(err);\r\n          };\r\n\r\n        self.getItem(key).then(function success(value) {\r\n          self.removeItem(key).then(function success() {\r\n            deferred.resolve(value);\r\n          }, onError);\r\n        }, onError);\r\n\r\n        return deferred.promise;\r\n      };\r\n\r\n      // Remove all data for this app from storage\r\n      LocalForageInstance.prototype.clear = function clear() {\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this;\r\n\r\n        self._localforage.clear().then(function success(keys) {\r\n          deferred.resolve();\r\n        }, function error(data) {\r\n          self.onError(data, args, self.clear, deferred);\r\n        });\r\n        return deferred.promise;\r\n      };\r\n\r\n      // Return the key for item at position n\r\n      LocalForageInstance.prototype.key = function key(n) {\r\n        // throw error on undefined n\r\n        if(angular.isUndefined(n)) {\r\n          throw new Error(\"You must define a position to get for the key function\");\r\n        }\r\n\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this;\r\n\r\n        self._localforage.key(n).then(function success(key) {\r\n          deferred.resolve(key);\r\n        }, function error(data) {\r\n          self.onError(data, args, self.key, deferred);\r\n        });\r\n        return deferred.promise;\r\n      };\r\n\r\n      var keys = function keys() {\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this;\r\n\r\n        self._localforage.keys().then(function success(keyList) {\r\n          if(defaultConfig.oldPrefix && self.driver() === 'localStorageWrapper') {\r\n            var tempKeyList = [];\r\n            for(var i = 0, len = keyList.length; i < len; i++) {\r\n              tempKeyList.push(keyList[i].substr(self.prefix().length, keyList[i].length));\r\n            }\r\n            keyList = tempKeyList;\r\n          }\r\n          deferred.resolve(keyList);\r\n        }, function error(data) {\r\n          self.onError(data, args, self.keys, deferred);\r\n        });\r\n        return deferred.promise;\r\n      };\r\n\r\n      // Return the list of keys stored for this application\r\n      LocalForageInstance.prototype.keys = keys;\r\n\r\n      // deprecated\r\n      LocalForageInstance.prototype.getKeys = keys;\r\n\r\n      // Returns the number of keys in this storage\r\n      LocalForageInstance.prototype.length = function() {\r\n        var deferred = $q.defer(),\r\n          args = arguments,\r\n          self = this;\r\n\r\n        self._localforage.length().then(function success(length) {\r\n          deferred.resolve(length);\r\n        }, function error(data) {\r\n          self.onError(data, args, length, deferred);\r\n        });\r\n        return deferred.promise;\r\n      };\r\n\r\n      /**\r\n       * Bind - let's you directly bind a LocalForage value to a $scope variable\r\n       * @param {Angular $scope} $scope - the current scope you want the variable available in\r\n       * @param {String/Object} opts - the key name of the variable you are binding OR an object with the key and custom options like default value or instance name\r\n       * Here are the available options you can set:\r\n       * * key: the key used in storage and in the scope (if scopeKey isn't defined)\r\n       * * defaultValue: the default value\r\n       * * name: name of the instance that should store the data\r\n       * * scopeKey: the key used in the scope\r\n       * @returns {*} - returns whatever the stored value is\r\n       */\r\n      LocalForageInstance.prototype.bind = function bind($scope, opts) {\r\n        if(angular.isString(opts)) {\r\n          opts = {\r\n            key: opts\r\n          }\r\n        } else if(!angular.isObject(opts) || angular.isUndefined(opts.key)) {\r\n          throw new Error(\"You must define a key to bind\");\r\n        }\r\n\r\n        var defaultOpts = {\r\n          defaultValue: '',\r\n          name: defaultConfig.name\r\n        };\r\n\r\n        // If no defined options we use defaults otherwise extend defaults\r\n        opts = angular.extend({}, defaultOpts, opts);\r\n\r\n        var self = lfInstances[opts.name];\r\n\r\n        if(angular.isUndefined(self)) {\r\n          throw new Error(\"You must use the name of an existing instance\");\r\n        }\r\n\r\n        // Set the storeName key for the LocalForage entry\r\n        // use user defined in specified\r\n        var scopeKey = opts.scopeKey || opts.key,\r\n          model = $parse(scopeKey);\r\n\r\n        return self.getItem(opts.key).then(function(item) {\r\n          if (item !== null) { // If it does exist assign it to the $scope value\r\n            model.assign($scope, item);\r\n          } else if(!angular.isUndefined(opts.defaultValue)) { // If a value doesn't already exist store it as is\r\n            model.assign($scope, opts.defaultValue);\r\n            self.setItem(opts.key, opts.defaultValue);\r\n          }\r\n\r\n          // Register a listener for changes on the $scope value\r\n          // to update the localForage value\r\n          if(angular.isDefined(watchers[opts.key])) {\r\n            watchers[opts.key]();\r\n          }\r\n\r\n          watchers[opts.key] = $scope.$watch(scopeKey, function(val) {\r\n            if(angular.isDefined(val)) {\r\n              self.setItem(opts.key, val);\r\n            }\r\n          }, true);\r\n          return item;\r\n        });\r\n      };\r\n\r\n      /**\r\n       * Unbind - let's you unbind a variable from localForage while removing the value from both\r\n       * the localForage and the local variable and sets it to null\r\n       * @param {String/Object} opts - the key name of the variable you are unbinding OR an object with the key and custom options like default value or instance name\r\n       * Here are the available options you can set:\r\n       * * key: the key used in storage and in the scope (if scopeKey isn't defined)\r\n       * * name: name of the instance that should store the data\r\n       * * scopeKey: the key used in the scope\r\n       */\r\n      LocalForageInstance.prototype.unbind = function unbind($scope, opts) {\r\n        if(angular.isString(opts)) {\r\n          opts = {\r\n            key: opts\r\n          }\r\n        } else if(!angular.isObject(opts) || angular.isUndefined(opts.key)) {\r\n          throw new Error(\"You must define a key to unbind\");\r\n        }\r\n\r\n        var defaultOpts = {\r\n          scopeKey: opts.key,\r\n          name: defaultConfig.name\r\n        };\r\n\r\n        // If no defined options we use defaults otherwise extend defaults\r\n        opts = angular.extend({}, defaultOpts, opts);\r\n\r\n        var self = lfInstances[opts.name];\r\n\r\n        if(angular.isUndefined(self)) {\r\n          throw new Error(\"You must use the name of an existing instance\");\r\n        }\r\n\r\n        $parse(opts.scopeKey).assign($scope, null);\r\n        if(angular.isDefined(watchers[opts.key])) {\r\n          watchers[opts.key](); // unwatch\r\n          delete watchers[opts.key];\r\n        }\r\n        return self.removeItem(opts.key);\r\n      };\r\n\r\n      LocalForageInstance.prototype.prefix = function() {\r\n        return this.driver() === 'localStorageWrapper' && defaultConfig.oldPrefix ? this._localforage.config().name + '.' : '';\r\n      };\r\n\r\n      // Handling errors\r\n      LocalForageInstance.prototype.onError = function(err, args, fct, deferred) {\r\n        // test for private browsing errors in Firefox & Safari\r\n        if(((angular.isObject(err) && err.name ? err.name === 'InvalidStateError' : (angular.isString(err) && err === 'InvalidStateError')) && this.driver() === 'asyncStorage')\r\n          || (angular.isObject(err) && err.code && err.code === 5)) {\r\n          var self = this;\r\n\r\n          self.setDriver('localStorageWrapper').then(function() {\r\n            fct.apply(self, args).then(function(item) {\r\n              deferred.resolve(item);\r\n            }, function(data) {\r\n              deferred.reject(data);\r\n            });\r\n          }, function() {\r\n            deferred.reject(err);\r\n          });\r\n        } else {\r\n          deferred.reject(err);\r\n        }\r\n      };\r\n\r\n      lfInstances[defaultConfig.name] = new LocalForageInstance();\r\n      return lfInstances[defaultConfig.name];\r\n    }]\r\n  });\r\n\r\n  angularLocalForage.directive('localForage', ['$localForage', function($localForage) {\r\n    return {\r\n      restrict: 'A',\r\n      link: function($scope, $element, $attrs) {\r\n        var opts = $scope.$eval($attrs.localForage);\r\n        if(angular.isObject(opts) && angular.isDefined(opts.key)) {\r\n          $localForage.bind($scope, opts);\r\n        } else {\r\n          $localForage.bind($scope, $attrs.localForage);\r\n        }\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return angularLocalForage.name;\r\n});\r\n\r\n","/*\r\n * ----------------------------------------\r\n *\r\n * Based on https://github.com/mozilla/localForage/blob/master/src/drivers/websql.js\r\n *\r\n */\r\nvar localforageSsatbDriver = {\r\n    DRIVER_NAME : 'localForage-SsatbDriver'\r\n};\r\n(function () {\r\n    'use strict';\r\n\r\n    // Promises!\r\n    var Promise = (typeof module !== 'undefined' && module.exports) ?\r\n        require('promise') : this.Promise;\r\n\r\n    var globalObject = this;\r\n    var serializer = null;\r\n\r\n\r\n    var ModuleType = {\r\n        DEFINE: 1,\r\n        EXPORT: 2,\r\n        WINDOW: 3\r\n    };\r\n\r\n    // Attaching to window (i.e. no module loader) is the assumed,\r\n    // simple default.\r\n    var moduleType = ModuleType.WINDOW;\r\n\r\n    // Find out what kind of module setup we have; if none, we'll just attach\r\n    // localForage to the main window.\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        moduleType = ModuleType.EXPORT;\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        moduleType = ModuleType.DEFINE;\r\n    }\r\n\r\n    function _initStorage(options) {\r\n        var self = this;\r\n        var apiInfo = null;\r\n        if (options) {\r\n            self._apiInfo = options.apiInfo;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function appendServiceResponseHeaders(obj, jqXHR) {\r\n        var headers = null;\r\n        if (obj != null)\r\n            if (jqXHR != null) {\r\n                var headersStr = jqXHR.getAllResponseHeaders();\r\n                var headersArray = headersStr.split(\"\\n\");\r\n                var headers = {};\r\n                for (var i in headersArray) {\r\n                    var header = headersArray[i];\r\n                    var kvs = header.split(\":\");\r\n                    var key = kvs[0];\r\n                    if (key) {\r\n                        key = key.trim();\r\n                        if (key.length != 0) {\r\n                            var val = kvs[1];\r\n                            if (val)\r\n                                val = val.trim();\r\n                            headers[key] = val;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else\r\n                console.warn(\"jqXHR is null. Headers not populated\");\r\n        if (headers != null)\r\n            obj.responseHeaders = headers;\r\n        return obj;\r\n    }\r\n\r\n    function iterate(iterator, callback) {\r\n        var self = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var apiInfo = getDefaultApiDetails(self._apiInfo);\r\n\r\n                $.ajax({\r\n                    method: apiInfo.iterate.verb ? apiInfo.iterate.verb : \"GET\",\r\n                    url: apiInfo.Url + apiInfo.iterate.url,\r\n                    headers: apiInfo.Headers,\r\n                    global: false,\r\n                    cache: false,\r\n                    dataType: \"json\",\r\n                    contentType: 'application/json; charset=utf-8',\r\n                }).done(function (items) {\r\n                    var length = items.length;\r\n                    for (var i = 0; i < length; i++) {\r\n                        var item = items[i];\r\n                        item = iterator(item, item[apiInfo.iterate.keyProperty],\r\n                                   i + 1);\r\n                        if (item !== void (0)) {\r\n                            resolve(item);\r\n                            return;\r\n                        }\r\n                    }\r\n                    resolve();\r\n                }).fail(function (jqXHR, textStatus, errorThrown) {\r\n                    reject(getServerError(apiInfo, jqXHR, textStatus, errorThrown));\r\n                });\r\n\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function getItem(key, callback) {\r\n        var self = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var apiDetails = getApiDetails(key);\r\n                var apiInfo = self._apiInfo[apiDetails.serviceName];\r\n\r\n                $.ajax({\r\n                    method: apiDetails.verb,\r\n                    url: apiInfo.Url + apiDetails.url,\r\n                    dataType: \"json\",\r\n                    global: false,\r\n                    cache: false,\r\n                    contentType: 'application/json; charset=utf-8',\r\n                    headers: apiInfo.Headers\r\n                }).done(function (obj, responseStatus, jqXHR) {\r\n                    resolve(appendServiceResponseHeaders(obj, jqXHR));\r\n                }).fail(function (jqXHR, textStatus, errorThrown) {\r\n                    reject(getServerError(apiDetails,jqXHR, textStatus, errorThrown));\r\n                });\r\n\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    function setItem(key, value, callback) {\r\n        var self = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var apiDetails = getApiDetails(key);\r\n                var apiInfo = self._apiInfo[apiDetails.serviceName];\r\n\r\n                $.ajax({\r\n                    method: apiDetails.verb,\r\n                    url: apiInfo.Url + apiDetails.url,\r\n                    dataType: \"json\",\r\n                    global: false,\r\n                    cache: false,\r\n                    contentType: 'application/json; charset=utf-8',\r\n                    headers: apiInfo.Headers,\r\n                    data: JSON.stringify(value)\r\n                }).done(function (response, responseStatus, jqXHR) {\r\n                    value.response = response;\r\n                    resolve(appendServiceResponseHeaders(value, jqXHR));\r\n                }).fail(function (jqXHR, textStatus, errorThrown) {\r\n                    reject(getServerError(apiDetails, jqXHR, textStatus, errorThrown));\r\n                });\r\n\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function removeItem(key, callback) {\r\n        var self = this;\r\n\r\n        // Cast the key to a string, as that's all we can set as a key.\r\n        if (typeof key !== 'string') {\r\n            window.console.warn(key +\r\n                ' used as a key, but it is not a string.');\r\n            key = String(key);\r\n        }\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var apiDetails = getApiDetails(key);\r\n                var apiInfo = self._apiInfo[apiDetails.serviceName];\r\n                $.ajax({\r\n                    method: apiDetails.verb,\r\n                    url: apiInfo.Url + apiDetails.url,\r\n                    global: false,\r\n                    cache: false,\r\n                    headers: apiInfo.Headers\r\n                }).done(function () {\r\n                    resolve()\r\n                }).fail(function (jqXHR, textStatus, errorThrown) {\r\n                    reject(getServerError(apiDetails, jqXHR, textStatus, errorThrown));\r\n                });\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function clear(callback) {\r\n        var self = this;\r\n\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function length(callback) {\r\n        var self = this;\r\n\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function key(n, callback) {\r\n        var self = this;\r\n\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n            }).catch(reject);\r\n        });\r\n\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function keys(callback) {\r\n        var self = this;\r\n\r\n        var promise = new Promise(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n            }).catch(reject);\r\n        });\r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n\r\n    function executeCallback(promise, callback) {\r\n        if (callback) {\r\n            promise.then(function (result) {\r\n                callback(null, result);\r\n            }, function (error) {\r\n                callback(error);\r\n            });\r\n        }\r\n    }\r\n\r\n    function getApiDetails(key) {\r\n        var api = key.split(\"|\");\r\n        return {\r\n            serviceName: api[0],\r\n            verb: api[1],\r\n            url: api[2]\r\n        };\r\n    }\r\n    function getDefaultApiDetails(apiHashmap) {\r\n        var defaultKey = null;\r\n        for (var firstKey in apiHashmap) {\r\n            defaultKey = firstKey;\r\n            break;\r\n        }\r\n        if (defaultKey == null)\r\n            return null;\r\n        return apiHashmap[defaultKey];\r\n    }\r\n\r\n    function getServerError(apiDetails, jqXHR, textStatus, errorThrown) {\r\n        return {\r\n            serviceName: apiDetails.serviceName,\r\n            method: apiDetails.verb,\r\n            status: jqXHR.status,\r\n            url: apiDetails.url,\r\n            statusText: textStatus,\r\n            errorThrown: errorThrown,\r\n            data: jqXHR.responseJSON\r\n        };\r\n    }\r\n\r\n\r\n    var driver = {\r\n        _driver: localforageSsatbDriver.DRIVER_NAME,\r\n        _initStorage: _initStorage,\r\n        _support: true,\r\n        iterate: iterate,\r\n        getItem: getItem,\r\n        setItem: setItem,\r\n        removeItem: removeItem,\r\n        clear: clear,\r\n        length: length,\r\n        key: key,\r\n        keys: keys\r\n    };\r\n    if (moduleType === ModuleType.DEFINE) {\r\n        define(localforageSsatbDriver.DRIVER_NAME, function () {\r\n            return driver;\r\n        });\r\n    } else if (moduleType === ModuleType.EXPORT) {\r\n        module.exports = driver;\r\n    } else {\r\n        this[localforageSsatbDriver.DRIVER_NAME] = driver;\r\n    }\r\n\r\n    localforage.defineDriver(driver);\r\n\r\n}).call(window);\r\n","angular.module('SSATB.LocalForage', ['LocalForageModule'])\r\n.provider('ssatbHttp', ['$localForageProvider', function ($localForageProvider) {\r\n\r\n    var _config = {\r\n        driver: [localforageSsatbDriver.DRIVER_NAME]\r\n    };\r\n\r\n    this.config = function (config) {\r\n        if (!angular.isObject(config))\r\n            throw new Error('The config parameter should be an object');\r\n\r\n        _config = angular.extend(_config, config);\r\n        $localForageProvider.config(_config);\r\n    };\r\n\r\n    var interceptorFactories = this.interceptors = [];\r\n\r\n    function getApiNameByUrl(url) {\r\n\r\n        if (!angular.isObject(_config.apiInfo))\r\n            return null;\r\n\r\n        var service = null;\r\n        angular.forEach(_config.apiInfo, function (value, key) {\r\n            if (url.toLowerCase().indexOf(value.Url.toLowerCase()) === 0) {\r\n                service = key;\r\n            }\r\n        });\r\n        return service;\r\n    }\r\n\r\n    this.$get = ['$localForage', '$q', '$injector', function ($localForage, $q, $injector) {\r\n\r\n        var reversedInterceptors = [];\r\n        angular.forEach(interceptorFactories, function (interceptorFactory) {\r\n            reversedInterceptors.unshift(angular.isString(interceptorFactory)\r\n                ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));\r\n        });\r\n\r\n        function ssatbHttp(requestConfig) {\r\n\r\n            if (!angular.isObject(requestConfig))\r\n                throw new Error('Http request configuration must be an object.');\r\n            if (!angular.isString(requestConfig.url))\r\n                throw new Error('Http request configuration url must be a string.');\r\n\r\n            var config = angular.extend({\r\n                method: 'get'\r\n            }, requestConfig);\r\n\r\n            config.method = angular.uppercase(config.method);\r\n\r\n            var service = getApiNameByUrl(requestConfig.url);\r\n            if (service === null)\r\n                throw new Error('No matching apiInfo was found in the provider configuration for the service URL ' + requestConfig.url);\r\n\r\n            var requestInterceptors = [];\r\n            var responseInterceptors = [];\r\n            var promise = $q.when(config);\r\n\r\n            // apply interceptors\r\n            angular.forEach(reversedInterceptors, function (interceptor) {\r\n                if (interceptor.request || interceptor.requestError) {\r\n                    requestInterceptors.unshift(interceptor.request, interceptor.requestError);\r\n                }\r\n                if (interceptor.response || interceptor.responseError) {\r\n                    responseInterceptors.push(interceptor.response, interceptor.responseError);\r\n                }\r\n            });\r\n\r\n            promise = chainInterceptors(promise, requestInterceptors);\r\n            promise = promise.then(function (result) {\r\n                var apiInfo = _config.apiInfo[service];\r\n                var key = service + '|' + config.method + '|' + requestConfig.url.substring(apiInfo.Url.length);\r\n                if (config.method === 'GET')\r\n                    return $localForage.getItem(key);\r\n                else\r\n                    if (config.method === 'DELETE')\r\n                        return $localForage.removeItem(key);\r\n                    else\r\n                        return $localForage.setItem(key, requestConfig.data);\r\n\r\n            });\r\n            promise = promise.then(function (response) {\r\n                if (response != null)\r\n                    response.config = config;\r\n                else\r\n                    return { config: config };\r\n                return response;\r\n\r\n            }, function (response) {\r\n                if (response != null) {\r\n                    response.config = config\r\n                    throw response\r\n                }\r\n                else {\r\n                    throw new { config: config };\r\n                }\r\n            });\r\n\r\n            return chainInterceptors(promise, responseInterceptors);\r\n        }\r\n\r\n        createShortMethods('get', 'delete');\r\n        createShortMethodsWithData('post', 'put');\r\n\r\n        return ssatbHttp;\r\n\r\n        function createShortMethods(names) {\r\n            angular.forEach(arguments, function (name) {\r\n                ssatbHttp[name] = function (url, config) {\r\n                    return ssatbHttp(angular.extend({}, config || {}, {\r\n                        method: name,\r\n                        url: url\r\n                    }));\r\n                };\r\n            });\r\n        }\r\n\r\n        function createShortMethodsWithData(name) {\r\n            angular.forEach(arguments, function (name) {\r\n                ssatbHttp[name] = function (url, data, config) {\r\n                    return ssatbHttp(angular.extend({}, config || {}, {\r\n                        method: name,\r\n                        url: url,\r\n                        data: data\r\n                    }));\r\n                };\r\n            });\r\n        }\r\n        function chainInterceptors(promise, interceptors) {\r\n            for (var i = 0, ii = interceptors.length; i < ii;) {\r\n                var thenFn = interceptors[i++];\r\n                var rejectFn = interceptors[i++];\r\n                promise = promise.then(thenFn, rejectFn);\r\n            }\r\n            interceptors.length = 0;\r\n            return promise;\r\n        }\r\n\r\n    }];\r\n\r\n}]);","(function () {\r\n    var authTokenRefreshService = (\r\n    function authTokenRefreshService($window, $http) {\r\n        this.$window = $window;\r\n        this.$http = $http;\r\n        return {\r\n            refreshToken: refreshToken\r\n        }\r\n        function refreshToken(refreshTokenBaseUrl,serviceName) {\r\n            var refreshTokenUrl = refreshTokenBaseUrl + '?serviceName=' + serviceName;\r\n\r\n            return $http.get(refreshTokenUrl).then(refreshTokenComplete);\r\n\r\n            function refreshTokenComplete(response) {\r\n                return response;\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n    var messageInterceptorsConfig = function ($provide, provider) {\r\n        // push function to the interceptors which will intercept all the http responses\r\n        provider.interceptors.push(['$q', '$injector', '$localForage', function ($q, $injector, $localForage) {\r\n            return {\r\n                responseError: function (errorResponse) {\r\n                    var deferred = $q.defer();\r\n                    var apiInfoObject = $localForage._localforage._apiInfo;\r\n                    var serviceName = getServiceNameFromApiInfo(apiInfoObject, errorResponse);\r\n                    var config = $injector.get('ssatbAuthTokenRefreshConfig');\r\n                    if (serviceName != null && config.refreshTokenUrl != null && !angular.isUndefined(errorResponse.config) && errorResponse.config != null\r\n                                && (angular.isUndefined(errorResponse.config.retry) || errorResponse.config.retry == false)\r\n                                    && errorResponse.status === 401) {\r\n                        $injector.get('authTokenRefreshService').refreshToken(config.refreshTokenUrl, serviceName).then(function (response) {\r\n                            var apiInfo = apiInfoObject[errorResponse.serviceName];\r\n                            apiInfo.Headers = response.data;\r\n                            _retrySsatbHttpRequest(errorResponse.config, deferred, $injector);\r\n                        }, function () {\r\n                            if (!angular.isUndefined(errorResponse.errorHandler) && config.errorHandler != null)\r\n                                config.errorHandler('An unexpected error occurred.  For assistance, please email info@enrollment.org.');\r\n                            deferred.reject(errorResponse);\r\n                        });\r\n                    } else {\r\n                        if (!angular.isUndefined(errorResponse.errorHandler) && config.errorHandler != null)\r\n                            config.errorHandler('An unexpected error occurred.  For assistance, please email info@enrollment.org.');\r\n                        deferred.reject(errorResponse);\r\n                    }\r\n                    return deferred.promise;\r\n\r\n                    function getServiceNameFromApiInfo(apiInfoObject, errorResponse)\r\n                    {\r\n                        if (errorResponse.serviceName == null)\r\n                            return null;\r\n                        var apiInfo = apiInfoObject[errorResponse.serviceName];\r\n                        if (apiInfo == null)\r\n                            return null;\r\n                        return apiInfo.ServiceName;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        ])\r\n    };\r\n    var _retrySsatbHttpRequest = function (config, deferred, $injector) {\r\n        $ssatbHttp = $injector.get('ssatbHttp');\r\n        config.retry = true;\r\n        $ssatbHttp(config).then(function (response) {\r\n            deferred.resolve(response);\r\n        }, function (response) {\r\n            alertDialog('An unexpected error occurred.  For assistance, please email info@enrollment.org.');\r\n            deferred.reject(response);\r\n        });\r\n    }\r\n    angular.module('ssatb.authtokenrefresh', ['SSATB.LocalForage'])\r\n        .provider('ssatbAuthTokenRefreshConfig', ['ssatbHttpProvider', function (ssatbHttpProvider) {\r\n            var _config = {};\r\n            this.config = function (config)\r\n            {\r\n                if (!angular.isObject(config))\r\n                    throw new Error('The config parameter should be an object');\r\n                _config = config;\r\n            }\r\n            this.$get = function () {\r\n                return _config;\r\n            }\r\n            }])\r\n        .config(['$provide', 'ssatbHttpProvider', messageInterceptorsConfig])\r\n      .service('authTokenRefreshService', ['$window', '$http', authTokenRefreshService]);\r\n})();\r\n"],"sourceRoot":"/source/"}